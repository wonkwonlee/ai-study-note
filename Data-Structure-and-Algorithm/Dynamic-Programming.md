# 다이나믹 프로그래밍 Dynamic Programming

## 다이나믹 프로그래밍 DP
* 최적의 해를 구하기에 시간이 매우 많이 필요하거나 메모리 공간이 매우 많이 필요한 경우 컴퓨터로도 해결하기 어려울 수 있다.
* 따라서 컴퓨터의 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성해야 한다.
* **다이나믹 프로그래밍 혹은 동적 계획법**은 *메모리 공간을 약간 더 사용하여 연산 속도를 비약적으로 증가시키는 방법*이다.

### 피보나치 수열 Fibonacci Sequence
```python
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)

print(fibo(4))
```
* 다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시로 피보나치 수열이 있다.
    + 피보나치 수열은 이전 두 항의 합을 현재의 항으로 설정하는 특징이 있는 수열이다.
* 기존의 재귀함수로 작성된 피보나치 수열의 소스코드의 경우 f(n) 함수에서 n이 커질수록 수행 시간이 기하급수적으로 커진다.
    + N = 30이면, 약 10억 번의 연산을 수행해야 한다.
* 이러한 피보나치 수열을 다이나믹 프로그래밍을 사용하면 효율적으로 해결할 수 있다.
* 다만 다이나믹 프로그램을 사용하려면 다음 조건을 만족해야 한다.
    1. 큰 문제를 작은 문제로 나눌 수 있다.
    2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.


## 메모이제이션 Memoization
* 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, **한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법**을 의미한다. 
* 메모이제이션은 값을 저장하는 방법이므로 **캐싱(Caching)** 이라고도 한다.
* 실제로 메모이제이션을 구현하기 위해서는 한 번 구한 정보를 리스트에 저장하는 것으로 간단히 구현할 수 있다.
    + 다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 정보가 필요할 때는 이미 구한 정답을 그대로 리스트에서 가져오면 된다.
* 다이나믹 프로그래밍이란 **큰 문제를 작게 나누고 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법**이다.
    + 따라서 이는 분할 정복 알고리즘으로 분류된다.
    + 다만 다이나믹 프로그래밍과 분할 정복의 차이점은 다이나믹 프로그래밍은 문제들이 서로 영향을 미치고 있다는 점이다.
* **재귀 함수**를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을 *큰 문제를 해결하기 위해 작은 문제를 호출한다*고 하여 **탑 다운(Top-Down) 혹은 하향식** 이라고 한다.
* **반복문**을 이용하여 소스코드를 작성하는 방법을 *작은 문제부터 차근차근 답을 도출한다* 하여 **바텀 업(Bottom-Up) 혹은 상향식** 이라고 한다.


#### Top-Down Memoization
```python
# Initialize list to store memoization result
d = [0] * 100

# Fibonacci in recursion
def fibo(x):
    # If x is 1 or 2, return 1
    if x == 1 or x == 2 :
        return 1
    # Get current val stored in d-array
    if d[x] != 0:
        return d[x]
    # If current value is unknown, calculate fib value and store it to d-array
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

print(fibo(99))

>> 218922995834555169026
```

#### Bottom-Up Memoization
```python
# Initialize list to store memoization result
d = [0] * 100

# First and second fib value is 1
d[1] = 1
d[2] = 1
n = 99

# Fibonacci function using for-loop
for i in range(3, n + 1):
  d[i] = d[i - 1] + d[i - 2]

print(d[n])

>> 218922995834555169026
```
* 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓은 넓은 개념으로 다이나믹 프로그래밍과는 별도의 개념이다.
    + 예를 들어, 한 번 계산된 결과를 어딘가에 저장하기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있다.
* 메모이제이션은 수열과 달리 연속적이지 않은 데이터를 해결하기 위해서는 사전(dict) 자료형을 사용하는 것이 더 효과적이다.


## 코딩 테스트에서의 다이나믹 프로그래밍
* 코딩 테스트에서의 다이나믹 프로그래밍 문제는 대체로 간단한 형태로 출제된다.
* 문제를 푸는 첫 번째 단계는 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 것이다.
* 만약 특정한 문제를 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 *다이나믹 프로그래밍을 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인*해야 한다.
* 가능하다면 재귀 함수를 이용하는 탑다운 방식보다는 *바텀업 방식으로 구현하는 것을 권장*한다.
    + 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있다.

